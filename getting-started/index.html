<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Getting Started</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on</span> GitHub</a> <a href="../"><img src="../assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="../"><img src="../assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="../getting-started/">Getting Started</a><!--
        --><a href="../api/">API Reference</a><!--
        --><a href="../plugins/">Plugins</a></nav></header><article><h1>Getting Started</h1><p>The first thing you&#39;ll have to do is install <a href="https://nodejs.org/">Node.js</a> 4.2+ (if you&#39;re on Linux, install <code>nodejs</code> from your package manager). Then install Fortune from the command-line:</p><pre><code class="lang-sh">$ npm <span class="hljs-keyword">install</span> fortune
</code></pre><p>Then create an empty <code>index.js</code> file adjacent to the <code>node_modules</code> folder, and start by importing Fortune and creating an instance:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> fortune = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fortune'</span>)
<span class="hljs-keyword">const</span> store = fortune()
</code></pre><p>The <code>fortune</code> function returns a new instance of Fortune, and accepts a configuration object as an argument. We don&#39;t need to pass any arguments to the constructor for now, the defaults should work.</p><h2 id="record-types">Record Types<a class="anchor" href="#record-types" title="Link to this section “Record Types”">#</a></h2><p>The only necessary input is record type definitions. Let&#39;s start with a basic example:</p><pre><code class="lang-js">store.defineType(<span class="hljs-string">'user'</span>, {
<span class="hljs-symbol">  username:</span> { <span class="hljs-string">type:</span> String },
<span class="hljs-symbol">  key:</span> { <span class="hljs-string">type:</span> Buffer },
<span class="hljs-symbol">  salt:</span> { <span class="hljs-string">type:</span> Buffer },
<span class="hljs-symbol">  group:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'group'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'users'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})

store.defineType(<span class="hljs-string">'group'</span>, {
<span class="hljs-symbol">  name:</span> { <span class="hljs-string">type:</span> String },
<span class="hljs-symbol">  users:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'group'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})
</code></pre><p>This defines a <code>user</code> record type that has a relationship to the <code>group</code> type. By default, relationships are to-one, unless <code>isArray</code> is specified. In this example, there is a many-to-many relationship between a user and a group. The <code>inverse</code> field specifies a corresponding field on the linked type, so that any update to either field will affect the other.</p><h2 id="transformation">Transformation<a class="anchor" href="#transformation" title="Link to this section “Transformation”">#</a></h2><p>Transformations can be defined per record type. Transform functions accept at least two arguments, the <code>context</code> object, the record, and optionally the <code>update</code> object for an <code>update</code> request. The method of an input transform may be any method except <code>find</code>, and an output transform may be applied to all methods.</p><p>Here are some implementation details for dealing with passwords:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> crypto = require(<span class="hljs-string">'crypto'</span>)

<span class="hljs-keyword">const</span> iterations = Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>)
<span class="hljs-keyword">const</span> keyLength = Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)
<span class="hljs-keyword">const</span> saltLength = Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)

<span class="hljs-function">function <span class="hljs-title">passwordCheck</span> <span class="hljs-params">(password, key, salt)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; crypto.pbkdf2(
    password, salt, iterations, keyLength, (<span class="hljs-keyword">error</span>, buffer) =&gt;
      <span class="hljs-keyword">error</span> ? reject(<span class="hljs-keyword">error</span>) : key.equals(buffer) ? resolve() : reject()))
}

function generateSalt () {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt;
    crypto.randomBytes(saltLength, (<span class="hljs-keyword">error</span>, buffer) =&gt;
    <span class="hljs-keyword">error</span> ? reject(<span class="hljs-keyword">error</span>) : resolve(buffer)))
}

function generateKey (password, salt) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt;
    crypto.pbkdf2(password, salt, iterations, keyLength, (<span class="hljs-keyword">error</span>, buffer) =&gt;
      <span class="hljs-keyword">error</span> ? reject(<span class="hljs-keyword">error</span>) : resolve(buffer)))
}
</code></pre><p>This is a pretty basic implementation using the <code>crypto</code> module provided by Node.js to check and generate passwords. For the user type, it would be a good idea to store the password as a cryptographically secure key, and to hide sensitive fields when displaying the record.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> methods = fortune.methods, errors = fortune.errors

store.transformInput('user', (context, record, update) =&gt; {
  <span class="hljs-keyword">const</span> request = context.request,
    <span class="hljs-keyword">method</span> = request.<span class="hljs-keyword">method</span>,
    <span class="hljs-keyword">type</span> = request.<span class="hljs-keyword">type</span>,
    headers = request.meta.headers

  <span class="hljs-keyword">let</span> key = record.key,
    salt = record.salt,
    password = record.password

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span> === methods.create &amp;&amp; !password)
    throw new errors.<span class="hljs-type">BadRequestError</span>(`<span class="hljs-type">Password</span> must be specified.`)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">method</span> !== methods.create ? passwordCheck(
    new <span class="hljs-type">Buffer</span>(headers['authorization'] || '', 'base64').toString(),
    key, salt.toString()) : <span class="hljs-type">Promise</span>.resolve()

  .catch(() =&gt; {
    throw new errors.<span class="hljs-type">UnauthorizedError</span>(`<span class="hljs-type">Incorrect</span> password.`)
  })

  .then(() =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span> === methods.delete) <span class="hljs-keyword">return</span> null
    <span class="hljs-keyword">if</span> (!password) password = update.replace.password

    <span class="hljs-keyword">return</span> generateSalt()
    .then(buffer =&gt; {
      salt = buffer
      <span class="hljs-keyword">return</span> generateKey(password, salt.toString())
    })
    .then(buffer =&gt; {
      key = buffer
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span> === methods.create) {
        record.key = key
        record.salt = salt
        <span class="hljs-keyword">return</span> record
      }
      update.replace = { key, salt }
      <span class="hljs-keyword">return</span> update
    })
  })
})
</code></pre><p>Input transform functions are run before anything gets persisted, so it is safe to throw errors. They may either synchronously return a value, or return a Promise. Note that the <code>password</code> field on the record is not defined in the record type, arbitrary fields are not persisted. Updating the password in this example requires a field in the <code>meta.headers</code> object, for example <code>Authorization: &quot;Zm9vYmFyYmF6cXV4&quot;</code> where the value is the base64 encoded old password.</p><p>It may be required to transform outputs as well. In this example, we don&#39;t want expose the salt and the key publicly:</p><pre><code class="lang-js">store.transformOutput(<span class="hljs-string">'user'</span>, <span class="hljs-function"><span class="hljs-params">(context, record)</span> =&gt;</span> {
  <span class="hljs-regexp">//</span> Hide sensitive fields.
  <span class="hljs-keyword">delete</span> record.salt
  <span class="hljs-keyword">delete</span> record.key
  <span class="hljs-keyword">return</span> record
})
</code></pre><p>The output transform has the same arguments as the input transform, but is applied on all requests. Some serializers may not show the resolved value of the output transform for certain requests, such as updating and deleting. It must return the record, either synchronously or as a promise.</p><h2 id="finishing">Finishing<a class="anchor" href="#finishing" title="Link to this section “Finishing”">#</a></h2><p>To start the application, we need to call the <code>connect</code> method.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> http = require(<span class="hljs-comment">'http')</span>

<span class="hljs-keyword">const</span> listener = fortune.net.http(store)
<span class="hljs-keyword">const</span> <span class="hljs-built_in">server</span> = http.createServer(listener)
<span class="hljs-keyword">const</span> port = <span class="hljs-number">1337</span>

store.connect().<span class="hljs-keyword">then</span>(() =&gt; {
  <span class="hljs-built_in">server</span>.listen(port)
  console.<span class="hljs-built_in">log</span>(`<span class="hljs-built_in">Server</span> <span class="hljs-keyword">is</span> listening <span class="hljs-keyword">on</span> port ${port}...`)
})
</code></pre><p>Using Fortune with HTTP is optional, but since the built-in serializers provide HTTP functionality in conjunction with the <code>fortune.net.http</code> module, it&#39;s easy to get started with it. The <code>fortune.net.http</code> module returns a listener function that accepts a <code>request</code> and <code>response</code> object that is generated by Node.js.</p><p>Starting the application:</p><pre><code class="lang-sh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">.</span>
</code></pre><p>Making a cURL request to the server:</p><pre><code class="lang-sh">$ curl -<span class="hljs-keyword">X</span> GET -<span class="hljs-keyword">H</span> <span class="hljs-string">"Accept: application/json"</span> -v http:<span class="hljs-comment">//localhost:1337</span>
</code></pre><p>The response should be an enumeration of types. Subsequent requests are templated: <code>/:type/:ids</code>. IDs may be comma separated.</p><p>It is advisable to use a hypermedia format over the wire, such as <a href="http://micro-api.org">Micro API</a>, there is <a href="https://github.com/fortunejs/fortune-micro-api">a serializer available</a>. Also it would be useful to persist data to disk, consult the <a href="http://fortunejs.com/plugins/">plugins page</a> for more information.</p></article><footer><p>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p><p>福</p></footer></body></html>