<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Fortune.js</title><meta name="description" content="Application middleware for Node.js and web browsers."><meta name="keywords" content="adapter,api,application,data,hypermedia,middleware,rest,serializer,transform"><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="./assets/piggu.png"><link rel="stylesheet" href="./assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on</span> GitHub</a> <a href="./"><img src="./assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="./"><img src="./assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="./getting-started/">Getting Started</a><!--
        --><a href="./api/">API Reference</a><!--
        --><a href="./plugins/">Plugins</a></nav></header><article><p>Fortune.js is application middleware for Node.js and web browsers. It exposes a data source via multiple formats through a uniform interface. Core features include application-level denormalized inverse relationships, transactions per request, update operators, transformations per record, and more.</p><p>The latest version is <strong>1.8.1</strong>, get it from <code>npm</code>:</p><pre class="install"><code>npm install <span class="hljs-literal">fortune</span> <span class="hljs-string">--save</span></code></pre><h4 id="abstract">Abstract<a class="anchor" href="#abstract" title="Link to this section “Abstract”">#</a></h4><blockquote><p>Most web apps at heart are user experience and business logic around a persistent store.</p></blockquote><p>Fortune.js deals with providing an interface to a data source. It does so by dynamically dispatching <code>Adapter</code>, <code>Serializer</code>, and <code>transform</code> methods based on data passed to the <code>request</code> method. Networking wrappers call the <code>request</code> method, so it is not coupled with any external protocol.</p><p>The <code>Adapter</code> abstraction allows for multiple persistence back-ends, such as common server-side databases like MongoDB and Postgres, and IndexedDB in the web browser.</p><p>The <code>Serializer</code> abstraction allows for multiple serialization formats, including media types such as <a href="http://jsonapi.org">JSON API</a> and <a href="http://micro-api.org">Micro API</a>, standard input formats such as URL encoded and form data, and custom serializers for HTML.</p><h2 id="example">Example<a class="anchor" href="#example" title="Link to this section “Example”">#</a></h2><p>The only necessary input is record type definitions. Record types in Fortune.js are the basic means of modelling data. Let&#39;s model a subset of Twitter&#39;s functionality:</p><pre><code class="lang-js"><span class="hljs-comment">// store.js</span>
const fortune = require(<span class="hljs-string">'fortune'</span>)

module.exports = fortune()

.defineType(<span class="hljs-string">'user'</span>, {
<span class="hljs-symbol">  name:</span> { <span class="hljs-string">type:</span> String },

  <span class="hljs-comment">// Following and followers are inversely related (many-to-many).</span>
<span class="hljs-symbol">  following:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'followers'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },
<span class="hljs-symbol">  followers:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'following'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },

  <span class="hljs-comment">// Many-to-one relationship of user posts to post author.</span>
<span class="hljs-symbol">  posts:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'post'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'author'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})

.defineType(<span class="hljs-string">'post'</span>, {
<span class="hljs-symbol">  message:</span> { <span class="hljs-string">type:</span> String },

  <span class="hljs-comment">// One-to-many relationship of post author to user posts.</span>
<span class="hljs-symbol">  author:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'posts'</span> }
})
</code></pre><p>By default, the data is persisted in memory. There are adapters for databases such as <a href="https://github.com/fortunejs/fortune-mongodb">MongoDB</a>, <a href="https://github.com/fortunejs/fortune-postgres">Postgres</a>, and <a href="https://github.com/fortunejs/fortune-nedb">NeDB</a>. Then let&#39;s add a HTTP server:</p><pre><code class="lang-js"><span class="hljs-comment">// server.js</span>
<span class="hljs-keyword">const</span> http = <span class="hljs-keyword">require</span>(<span class="hljs-string">'http'</span>)
<span class="hljs-keyword">const</span> fortune = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fortune'</span>)
<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">require</span>(<span class="hljs-string">'./store'</span>)

<span class="hljs-comment">// The `fortune.net.http` helper function returns a listener function which</span>
<span class="hljs-comment">// does content negotiation, and maps the internal response to a HTTP response.</span>
<span class="hljs-keyword">const</span> server = http.createServer(fortune.net.http(store))

store.connect().then(() =&gt; server.listen(<span class="hljs-number">1337</span>))
</code></pre><p>This yields an <em>ad hoc</em> JSON-over-HTTP API. There are serializers for <a href="https://github.com/fortunejs/fortune-micro-api">Micro API</a> (JSON-LD) and <a href="https://github.com/fortunejs/fortune-json-api">JSON API</a>.</p><p>See the <a href="http://fortunejs.com/plugins/">plugins page</a> for more details.</p><h2 id="features-and-non-features">Features and Non-Features<a class="anchor" href="#features-and-non-features" title="Link to this section “Features and Non-Features”">#</a></h2><ul><li>Entity-relationship modelling, via record type definitions.</li><li>Inverse relationships, handled internally when calling <code>request</code>.</li><li>Abstractions for manipulating data (<code>Adapter</code>, <code>Serializer</code>, <code>transform</code>).</li><li><em>Isomorphic</em>, backed by IndexedDB in web browsers.</li><li><strong>No</strong> architectural decisions such as MVC, et al.</li><li><strong>No</strong> coupling with network protocol. Although a <code>http</code> listener is included for Node.js, it&#39;s optional to use.</li><li><strong>No</strong> routing in core, this may be handled by the <code>Serializer</code> implementation, or externally, or not at all.</li></ul><p>The intent is to provide common CRUD functionality, without unnecessary concepts or bloat. Extra functionality should be delegated to appropriate tools instead of trying to do everything here.</p></article><footer><p>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p><p>福</p></footer></body></html>